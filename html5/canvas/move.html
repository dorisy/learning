<!doctype html>
<html>
	<head></head>
	<body>
		<canvas id="canvas" width="600" height="600" style="border:solid black 1px;">
		Your browser does not support canvas element.
		</canvas>
		<br>
		<button onclick="startup()">Initialize</button>
		<br>
		Log: <pre id="log" style="border: 1px solid #ccc;"></pre>
		<script type="text/javascript">
		function startup() {
		  var el = document.getElementsByTagName("canvas")[0];
		  el.addEventListener("touchstart", handleStart, false);
		  el.addEventListener("touchend", handleEnd, false);
		  el.addEventListener("touchcancel", handleCancel, false);
		  el.addEventListener("touchleave", handleEnd, false);
		  el.addEventListener("touchmove", handleMove, false);
		  log("initialized.");
		}
		var ongoingTouches = new Array();
		function handleStart(evt) {
		  evt.preventDefault();
		  log("touchstart.");
		  var el = document.getElementsByTagName("canvas")[0];
		  var ctx = el.getContext("2d");
		  var touches = evt.changedTouches;
		        
		  for (var i=0; i < touches.length; i++) {
		    log("touchstart:"+i+"...");
		    ongoingTouches.push(copyTouch(touches[i]));
		    var color = colorForTouch(touches[i]);
		    ctx.beginPath();
		    ctx.arc(touches[i].pageX, touches[i].pageY, 4, 0,2*Math.PI, false);  // a circle at the start
		    ctx.fillStyle = color;
		    ctx.fill();
		    log("touchstart:"+i+".");
		  }
		}
		function handleMove(evt) {
		  evt.preventDefault();
		  var el = document.getElementsByTagName("canvas")[0];
		  var ctx = el.getContext("2d");
		  var touches = evt.changedTouches;//页面上最新更改的所有触摸，即最后一次发生的事情
		  /*
		   targetTouches 目标元素的所有当前触摸 changedTouches 页面上最新更改的所有触摸 touches 页面上的所有触摸
		   changedTouches、targetTouches和touches分别包含稍微不同的触摸列表。targetTouches和touches分别包含当前位于 屏幕上的手指列表，但changedTouches仅列出最后发生的触摸。如果你在使用touchend或者gestureend事件，那么这个属性 非常重要。在这两种情况下，屏幕上都不会再出现手指，因此targetTouches和touches应该为空，但你仍然可以通过查看 changedTouches数组来了解最后发生的事情。
		   由于触摸属性都会生成数组，因此你可以使用JavaScript数组函数来访问它们。这意味着，event.touches[0]将返回第一次 触摸，并且可以使用event.touches.length来计算当前存储的触摸数量。
		   查看单独触摸时，通过使用event.targetTouches[0],你也可以访问其它触摸，每个触摸会包含一些具体信息，
		   clientX、clientY 相对于当前屏幕的X或Y位置 pageX、pageY 相对于整体页面的X或Y位置 screenX、screenY 相对于用户计算机屏幕的X或Y位置 identifier 事件的唯一标识符 target 生成触摸的目标对象
		   手势事件的事件对象会比普通触摸事件多两个属性，
		   rotation 手指的旋转角度 scale 放缩的值
		  */

		  for (var i=0; i < touches.length; i++) {
		    var color = colorForTouch(touches[i]);
		    var idx = ongoingTouchIndexById(touches[i].identifier);

		    if(idx >= 0) {
		      log("continuing touch "+idx);
		      ctx.beginPath();
		      log("ctx.moveTo("+ongoingTouches[idx].pageX+", "+ongoingTouches[idx].pageY+");");
		      ctx.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);
		      log("ctx.lineTo("+touches[i].pageX+", "+touches[i].pageY+");");
		      ctx.lineTo(touches[i].pageX, touches[i].pageY);
		      ctx.lineWidth = 4;
		      ctx.strokeStyle = color;
		      ctx.stroke();

		      ongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
		      log(".");
		    } else {
		      log("can't figure out which touch to continue");
		    }
		  }
		}
		function handleEnd(evt) {
		  evt.preventDefault();
		  log("touchend/touchleave.");
		  var el = document.getElementsByTagName("canvas")[0];
		  var ctx = el.getContext("2d");
		  var touches = evt.changedTouches;

		  for (var i=0; i < touches.length; i++) {
		    var color = colorForTouch(touches[i]);
		    var idx = ongoingTouchIndexById(touches[i].identifier);

		    if(idx >= 0) {
		      ctx.lineWidth = 4;
		      ctx.fillStyle = color;
		      ctx.beginPath();
		      ctx.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);
		      ctx.lineTo(touches[i].pageX, touches[i].pageY);
		      ctx.fillRect(touches[i].pageX-4, touches[i].pageY-4, 8, 8);  // and a square at the end
		      ongoingTouches.splice(idx, 1);  // remove it; we're done
		    } else {
		      log("can't figure out which touch to end");
		    }
		  }
		}
		function handleCancel(evt) {
		  evt.preventDefault();
		  log("touchcancel.");
		  var touches = evt.changedTouches;
		  
		  for (var i=0; i < touches.length; i++) {
		    ongoingTouches.splice(i, 1);  // remove it; we're done
		  }
		}
		function colorForTouch(touch) {
		  var r = touch.identifier % 16;
		  var g = Math.floor(touch.identifier / 3) % 16;
		  var b = Math.floor(touch.identifier / 7) % 16;
		  r = r.toString(16); // make it a hex digit
		  g = g.toString(16); // make it a hex digit
		  b = b.toString(16); // make it a hex digit
		  var color = "#" + r + g + b;
		  log("color for touch with identifier " + touch.identifier + " = " + color);
		  return color;
		}
		function copyTouch(touch) {
		  return { identifier: touch.identifier, pageX: touch.pageX, pageY: touch.pageY };
		}
		function ongoingTouchIndexById(idToFind) {
		  for (var i=0; i < ongoingTouches.length; i++) {
		    var id = ongoingTouches[i].identifier;
		    
		    if (id == idToFind) {
		      return i;
		    }
		  }
		  return -1;    // not found
		}
		function log(msg) {
		  var p = document.getElementById('log');
		  p.innerHTML = msg + "\n" + p.innerHTML;
		}
		function onTouch(evt) {
		  evt.preventDefault();
		  if (evt.touches.length > 1 || (evt.type == "touchend" && evt.touches.length > 0))
		    return;

		  var newEvt = document.createEvent("MouseEvents");
		  var type = null;
		  var touch = null;
		  switch (evt.type) {
		    case "touchstart":    type = "mousedown";    touch = evt.changedTouches[0];break;
		    case "touchmove":        type = "mousemove";    touch = evt.changedTouches[0];break;
		    case "touchend":        type = "mouseup";    touch = evt.changedTouches[0];break;
		  }
		  newEvt.initMouseEvent(type, true, true, evt.originalTarget.ownerDocument.defaultView, 0,
		    touch.screenX, touch.screenY, touch.clientX, touch.clientY,
		    evt.ctrlKey, evt.altKey, evt.shirtKey, evt.metaKey, 0, null);
		  evt.originalTarget.dispatchEvent(newEvt);
		}
		</script>
	</body>
</html>
